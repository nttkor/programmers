'''
문제 요약
격자: N
timesN 크기의 2차원 격자가 주어집니다. 각 칸 $(r, c)$의 값 $A_{r,c}$는 0 또는 1입니다.
A_r,c=0: 이동 가능한 칸입니다.
A_r,c=1: 이동 불가능한 칸입니다.
시작과 목표:
시작 지점: (1,1)
목표 지점: (N,N)
이동 규칙:
초기 방향: 처음 $(1, 1)$에서 출발할 때 오른쪽 또는 아래쪽 중 하나의 방향을 선택합니다.
이동: 한 번에 한 칸씩 현재 바라보고 있는 방향으로 이동합니다.
방향 전환:
현재 방향을 유지하거나, 방향을 전환할 수 있습니다.

오른쪽 → 아래쪽으로만 전환 가능합니다.
아래쪽 → 오른쪽으로만 전환 가능합니다.
위쪽이나 왼쪽으로의 전환은 불가능합니다.

문제: $(1, 1)$에서 $(N, N)$까지 도달할 수 있는 경로가 존재하는지 판단하고, 존재한다면 그 경로를 찾아야 합니다.
문제 해결을 위한 접근법
이 문제는 그래프 탐색 알고리즘을 사용하여 해결할 수 있습니다. 특히, 최단 경로를 찾는 문제가 아니라 경로의 존재 여부를 묻는 문제이므로 **너비 우선 탐색(BFS)**이나 **깊이 우선 탐색(DFS)**을 사용하는 것이 적합합니다.
상태 정의
이동 경로를 추적하기 위해서는 현재 위치뿐만 아니라 현재 방향도 함께 고려해야 합니다. 따라서 상태를 $(r, c, \text{방향})$으로 정의할 수 있습니다.
r,c: 현재 위치 (행, 열)
text방향: 현재 바라보고 있는 방향 (오른쪽 또는 아래쪽)
BFS를 이용한 해결
큐(Queue) 초기화: 큐에 시작 상태를 넣습니다.
시작점 $(1, 1)$에서 오른쪽으로 가는 경우: 큐에 (1, 1, '오른쪽')을 추가합니다.
시작점 $(1, 1)$에서 아래쪽으로 가는 경우: 큐에 (1, 1, '아래쪽')을 추가합니다.
방문 여부 배열(Visited Array) 초기화: 동일한 상태를 중복해서 탐색하지 않도록 visited[r][c][방향]와 같은 3차원 배열을 사용합니다.
visited[r][c][0]는 $(r, c)$에서 오른쪽으로 이동하는 경로를, visited[r][c][1]은 아래쪽으로 이동하는 경로를 방문했는지 기록합니다.
탐색 시작: 큐가 빌 때까지 다음을 반복합니다.
큐에서 하나의 상태 $(r, c, \text{방향})$을 꺼냅니다.
만약 $(r, c)$가 목표 지점 $(N, N)$이라면, 경로가 존재하므로 탐색을 종료하고 True를 반환합니다.
다음 상태 탐색:
현재 방향으로 직진: 현재 방향으로 한 칸 이동한 다음 칸 $(nr, nc)$를 계산합니다.
$(nr, nc)$가 격자 내부에 있고, A_nr,nc=0이며, 아직 방문하지 않은 상태라면, 큐에 (nr, nc, 방향)을 추가하고 방문했다고 표시합니다.
방향 전환: 이동 규칙에 따라 방향을 전환합니다.
현재 방향이 '오른쪽'이면 '아래쪽'으로, '아래쪽'이면 '오른쪽'으로 전환합니다.
전환 후 현재 위치에서 새로운 방향으로 이동할 수 있는지 확인합니다. 즉, 방향 전환 후 이동할 칸이 격자 내부에 있고 A_nr,nc=0이며, 아직 방문하지 않은 상태라면, 큐에 (nr, nc, 새로운_방향)을 추가하고 방문했다고 표시합니다.
탐색 종료: 큐가 비었는데도 목표 지점에 도달하지 못했다면, 경로가 존재하지 않으므로 False를 반환합니다.
DFS를 이용한 해
DFS도 비슷한 방식으로 재귀 함수를 이용해 구현할 수 있습니다. 단, 스택 오버플로우를 방지하기 위해 재귀 깊이 제한을 설정하거나 반복문을 이용한 스택 기반 구현을 고려할 수 있습니다.
'''


def solve(n,k):
    dir = [(1,0),(0,1)]
    def dfs(x,y,cnt,pi):
        if x==n and y==n:
            return 1
        for i, dx,dy in enumerate(dir):
            nx, ny = x+dx,y+dy
            if nx<n and ny<n and cnt < k:
                inc = 0
                if pi != i and cnt >= 0:
                    inc = 1
                sum += dfs(nx,ny,cnt+inc,i)
        return 0
    sum = 0
    dfs(0,0,0,-1)



n=3
k = 1
N = [[0]*n for _ in range(n)]
#N[1][1] = 1
print(N)
solve(n,k)